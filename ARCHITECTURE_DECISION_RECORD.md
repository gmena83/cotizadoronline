# Architecture Decision Record (ADR): Menatech Application

This document outlines the key architectural decisions for the Menatech Project Management and Client Onboarding application.

## 1. Frontend Framework: Next.js (React) with TypeScript

*   **Decision**: We will use Next.js as the frontend framework.
*   **Justification**:
    *   **Full-Stack Capabilities**: Next.js provides an integrated full-stack experience, perfect for an application with both a secure admin area and public-facing client portals. Features like file-system routing, server-side rendering (SSR), and API routes are built-in.
    *   **React Ecosystem**: Leverages the vast and mature React ecosystem, enabling rapid development with a rich selection of libraries and components.
    *   **Performance**: Delivers excellent performance out-of-the-box with features like automatic code-splitting, image optimization, and static site generation capabilities.
    *   **Type Safety**: First-class TypeScript support ensures a robust and maintainable codebase, which is critical for a business application of this complexity.

## 2. Backend Framework: Node.js/Express with TypeScript

*   **Decision**: The backend will be a dedicated Node.js application using the Express framework, written in TypeScript.
*   **Justification**:
    *   **JavaScript Unification**: Using TypeScript on both the frontend and backend simplifies development, allows for code-sharing (e.g., shared types), and creates a cohesive development environment.
    *   **Asynchronous Nature**: Node.js's non-blocking, event-driven architecture is highly efficient for I/O-bound operations, which are central to this application (e.g., handling API requests, database calls, and integrating with third-party services like OpenAI and Google Drive).
    *   **Real-time Features**: The requirement for an instantly-updating client dashboard (Module 5) necessitates WebSockets. Node.js has excellent, mature libraries like `Socket.IO` for this purpose.
    *   **Vibrant Ecosystem**: The npm ecosystem provides battle-tested libraries for all required backend functionality, from security (`helmet`) to API integration.

## 3. Database: PostgreSQL

*   **Decision**: PostgreSQL will be our primary database.
*   **Justification**:
    *   **Data Integrity**: The application's data model is highly relational (clients, projects, proposals, hierarchical work orders). PostgreSQL's strict relational integrity and support for transactions are essential for maintaining data consistency in a business-critical system.
    *   **Scalability & Reliability**: PostgreSQL is renowned for its stability, performance with complex queries, and proven ability to scale to large datasets.
    *   **Flexible Data Types**: Its robust support for various data types, including `JSONB`, is ideal for storing the structured-yet-flexible data that will be generated by the LLM (e.g., the One-Pager analysis).

## 4. ORM/Query Builder: Prisma

*   **Decision**: We will use Prisma as the ORM to interact with the PostgreSQL database.
*   **Justification**:
    *   **Ultimate Type Safety**: Prisma auto-generates a TypeScript client from the database schema. This provides unparalleled, end-to-end type safety, ensuring that database queries are validated at compile time, not runtime. This is the cornerstone of a reliable TypeScript backend.
    *   **Declarative Schema as Single Source of Truth**: The `schema.prisma` file is an intuitive, human-readable definition of our database schema. It's far more manageable than writing and tracking SQL migration scripts manually.
    *   **Superior Developer Experience**: Prisma offers an exceptional developer experience with tools like Prisma Studio (a GUI for database browsing), a straightforward migration system, and an expressive query API that significantly speeds up development.
